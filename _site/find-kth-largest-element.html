<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Find kth largest element | mwpb blog</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Find kth largest element" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="write ups of topics in coding and mathematics to help me remember them" />
<meta property="og:description" content="write ups of topics in coding and mathematics to help me remember them" />
<link rel="canonical" href="http://localhost:4000/find-kth-largest-element.html" />
<meta property="og:url" content="http://localhost:4000/find-kth-largest-element.html" />
<meta property="og:site_name" content="mwpb blog" />
<script type="application/ld+json">
{"description":"write ups of topics in coding and mathematics to help me remember them","@type":"WebPage","url":"http://localhost:4000/find-kth-largest-element.html","headline":"Find kth largest element","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=aff6b1ae1ad25e02222b62962e5b1b546a5612a6">
  </head>
  <body>
    <div class="container-lg px-3 my-5 markdown-body">
      
      <h1><a href="http://localhost:4000/">mwpb blog</a></h1>
      

      <h1 id="find-kth-largest-element">Find kth largest element</h1>

<p>(Elements of programming interviews 11.8.)</p>

<p>Consider the problem of finding the <code class="highlighter-rouge">k</code>th largest element in an unsorted array.
We can use the following modification of heap sort.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">heapq</span>
<span class="k">def</span> <span class="nf">kth_largest</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span> <span class="c"># O(n log(k))</span>
    <span class="n">min_heap</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">min_heap</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">:</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">min_heap</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">min_heap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">:</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappushpop</span><span class="p">(</span><span class="n">min_heap</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">min_heap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></code></pre></figure>

<p>which runs in <code class="highlighter-rouge">O(N*log(K))</code> time because each call to <code class="highlighter-rouge">heappush</code> or <code class="highlighter-rouge">heappushpop</code> is <code class="highlighter-rouge">O(log(K))</code>.</p>

<p>In fact if we use a variation of quicksort we can get an <em>average-case</em> time complexity of <code class="highlighter-rouge">O(N)</code> but a worst-case time complexity of <code class="highlighter-rouge">O(N^2)</code>.
The idea is that by partitioning the array around a pivot element we can eliminate many elements of the array at once.
An extremely rough implementation might be as follows:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">randrange</span>
<span class="k">def</span> <span class="nf">qs_imitation</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span> <span class="c"># worst case O(N^2) average case O(N)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">'qs_imitation({l}, {k})'</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">randrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">))</span>
    <span class="n">pivot</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
    <span class="n">above</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">below</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">same</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">pivot</span><span class="p">:</span>
            <span class="n">above</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="p">:</span>
            <span class="n">below</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">same</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">below</span><span class="p">,</span> <span class="n">same</span><span class="p">,</span> <span class="n">above</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">above</span><span class="p">)</span> <span class="o">==</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pivot</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">above</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">qs_imitation</span><span class="p">(</span><span class="n">above</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">above</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">same</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pivot</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">qs_imitation</span><span class="p">(</span><span class="n">below</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">above</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">same</span><span class="p">))</span></code></pre></figure>

<p>where the problem is that we have no way of guaranteeing that the randomly chosen element isnâ€™t the largest element each time.</p>


      
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.0/anchor.min.js" integrity="sha256-lZaRhKri35AyJSypXXs4o6OPFTbTmUoltBbDCbdzegg=" crossorigin="anonymous"></script>
    <script>anchors.add();</script>
    
  </body>
</html>
