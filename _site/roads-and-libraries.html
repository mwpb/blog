<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Roads and libraries | mwpb blog</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Roads and libraries" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="write ups of topics in coding and mathematics to help me remember them" />
<meta property="og:description" content="write ups of topics in coding and mathematics to help me remember them" />
<link rel="canonical" href="http://localhost:4000/roads-and-libraries.html" />
<meta property="og:url" content="http://localhost:4000/roads-and-libraries.html" />
<meta property="og:site_name" content="mwpb blog" />
<script type="application/ld+json">
{"description":"write ups of topics in coding and mathematics to help me remember them","@type":"WebPage","url":"http://localhost:4000/roads-and-libraries.html","headline":"Roads and libraries","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=8e4255953dd8cee03ca4d7ab8d8eabcc17c3c562">
  </head>
  <body>
    <div class="container-lg px-3 my-5 markdown-body">
      
      <h1><a href="http://localhost:4000/">mwpb blog</a></h1>
      

      <h1 id="roads-and-libraries">Roads and libraries</h1>

<p>(Inspired by the ‘roads and libraries’ challenge on Hackerrank.)</p>

<p>Both the breadth-first (bfs) and depth-first (dfs) graph traversal algorithms have  time complexity equal to <code class="highlighter-rouge">O(v+e)</code> where <code class="highlighter-rouge">v</code> is the number of vertices and <code class="highlighter-rouge">e</code> is the number of edges.
This is because in the worst case we must visit each vertex and consider each edge.
So unless the problem is particularly simple it is probably a good idea to use one of these traversals.
Both bfs and dfs work on adjacency lists.
If one has an edge list one can convert it to an adjacency list in <code class="highlighter-rouge">O(n+m)</code> time.
But if one has an adjacency matrix one has to use <code class="highlighter-rouge">O(n^2)</code> time to convert to an adjacency list.</p>

<p>If we are searching for a specific element then the choice between the two is dictated by the structure of the graph and where we might expect the solution to be given the problem at hand.
(If we are trying to find the shortest distance then BFS is the better as it can be slightly modified to deterministically calculate the shortest distance.)
In terms of time complexity the choice of BFS vs DFS shouldn’t matter if we plan to traverse the whole graph.</p>

<p>DFS generally has the better space complexity as it only keeps track of a ‘search path’ as a stack whereas BFS has to keep track of a queue.
Every time one removes a vertex from this queue one adds all of the unvisited neighbours of that queue so the space usage can increase quite rapidly.</p>

<p>Side note: the standard pre-order, post-order and in-order tree traversals appear to be examples of DFSs.
It appears that one can use a BFS on a tree also.</p>

<p>This post is a reaction to my attempts at the ‘roads and libraries’ challenge on Hackerrank.
Initially I tried to use a cache to keep track of the connected components that a vertex belonged to.
However it quickly became apparent that my attempts to keep this cache updated correctly wasn’t going to get better than <code class="highlighter-rouge">O(v+e)</code>.
Then I tried a BFS with <em>an inappropriate Python queue library</em>.
(I used <code class="highlighter-rouge">queue.Queue()</code> rather than <code class="highlighter-rouge">collections.deque</code>.)</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">bfs_wrong_queue</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">adj_list</span><span class="p">,</span> <span class="n">visited</span><span class="p">):</span> <span class="c"># O(??)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>
    <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span><span class="p">]</span>
    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">q</span><span class="o">.</span><span class="n">qsize</span><span class="p">():</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">adj_list</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span><span class="p">,</span> <span class="n">visited</span></code></pre></figure>

<p>With this mistake a single Hackerrank test case gave me a: <code class="highlighter-rouge">Terminated due to timeout</code>.
(All the rest passed.)
Next using the usual Python list as a stack I implemented a DFS which passed all of the Hackerrank test cases.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">adj_list</span><span class="p">,</span> <span class="n">visited</span><span class="p">):</span> <span class="c"># O(v+e)</span>
    <span class="n">search_path</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span><span class="p">]</span>
    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span><span class="p">]</span>
    <span class="k">while</span> <span class="n">search_path</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">search_path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">adj_list</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
            <span class="n">search_path</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">next_node</span> <span class="o">=</span> <span class="n">adj_list</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">next_node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">next_node</span><span class="p">)</span>
                <span class="n">search_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_node</span><span class="p">)</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_node</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span><span class="p">,</span> <span class="n">visited</span></code></pre></figure>

<p>At this point I tried quite hard (and in vain) to find a good reason why DFS was a better choice <em>in terms of time complexity</em>.
This was complicated by the fact that people seem to prefer DFS when visiting every vertex.
(Presumably this is for the space-saving advantages mentioned above.)
When I realised my mistake and used the appropriate queue library my BFS solution passed the Hackerrank test cases also:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">adj_list</span><span class="p">,</span> <span class="n">visited</span><span class="p">):</span> <span class="c"># O(v+e)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
    <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span><span class="p">]</span>
    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">adj_list</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span><span class="p">,</span> <span class="n">visited</span></code></pre></figure>

<p>The complete solution is displayed below:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">queue</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">def</span> <span class="nf">get_adj_list</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">edges</span><span class="p">):</span> <span class="c"># O(v+e)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">edge</span>
        <span class="n">out</span><span class="p">[</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="n">b</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span>

<span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">adj_list</span><span class="p">,</span> <span class="n">visited</span><span class="p">):</span> <span class="c"># O(v+e)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
    <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span><span class="p">]</span>
    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">adj_list</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span><span class="p">,</span> <span class="n">visited</span>

<span class="k">def</span> <span class="nf">bfs_wrong_queue</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">adj_list</span><span class="p">,</span> <span class="n">visited</span><span class="p">):</span> <span class="c"># O(??)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>
    <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span><span class="p">]</span>
    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">q</span><span class="o">.</span><span class="n">qsize</span><span class="p">():</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">adj_list</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span><span class="p">,</span> <span class="n">visited</span>

<span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">adj_list</span><span class="p">,</span> <span class="n">visited</span><span class="p">):</span> <span class="c"># O(v+e)</span>
    <span class="n">search_path</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span><span class="p">]</span>
    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span><span class="p">]</span>
    <span class="k">while</span> <span class="n">search_path</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">search_path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">adj_list</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
            <span class="n">search_path</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">next_node</span> <span class="o">=</span> <span class="n">adj_list</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">next_node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">next_node</span><span class="p">)</span>
                <span class="n">search_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_node</span><span class="p">)</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_node</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span><span class="p">,</span> <span class="n">visited</span>


<span class="k">def</span> <span class="nf">roadsAndLibraries</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">c_lib</span><span class="p">,</span> <span class="n">c_road</span><span class="p">,</span> <span class="n">cities</span><span class="p">):</span> <span class="c"># O(v*(v+e))</span>
    <span class="k">if</span> <span class="n">c_lib</span> <span class="o">&lt;=</span> <span class="n">c_road</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n</span><span class="o">*</span><span class="n">c_lib</span>
    <span class="n">adj_list</span> <span class="o">=</span> <span class="n">get_adj_list</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)),</span> <span class="n">cities</span><span class="p">)</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
    <span class="k">for</span> <span class="n">start</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span> <span class="c"># repeated for every connected component</span>
            <span class="n">comp</span><span class="p">,</span> <span class="n">visited</span> <span class="o">=</span> <span class="n">bfs</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">adj_list</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>
            <span class="n">cost</span> <span class="o">+=</span> <span class="n">c_lib</span> <span class="o">+</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">c_road</span>
    <span class="k">return</span> <span class="n">cost</span></code></pre></figure>


      
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.0/anchor.min.js" integrity="sha256-lZaRhKri35AyJSypXXs4o6OPFTbTmUoltBbDCbdzegg=" crossorigin="anonymous"></script>
    <script>anchors.add();</script>
    
  </body>
</html>
