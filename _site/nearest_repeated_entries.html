<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Find the nearest repeated entries in an array | mwpb blog</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Find the nearest repeated entries in an array" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="write ups of topics in coding and mathematics to help me remember them" />
<meta property="og:description" content="write ups of topics in coding and mathematics to help me remember them" />
<link rel="canonical" href="http://localhost:4000/nearest_repeated_entries.html" />
<meta property="og:url" content="http://localhost:4000/nearest_repeated_entries.html" />
<meta property="og:site_name" content="mwpb blog" />
<script type="application/ld+json">
{"description":"write ups of topics in coding and mathematics to help me remember them","@type":"WebPage","url":"http://localhost:4000/nearest_repeated_entries.html","headline":"Find the nearest repeated entries in an array","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=760ab785fcdff40d612430393437d37ffab05abb">
  </head>
  <body>
    <div class="container-lg px-3 my-5 markdown-body">
      
      <h1><a href="http://localhost:4000/">mwpb blog</a></h1>
      

      <h1 id="find-the-nearest-repeated-entries-in-an-array">Find the nearest repeated entries in an array</h1>

<p>(Elements of programming interviews 12.5.)</p>

<p>One way of improving time complexity at the expense of space complexity is to use a cache.
If a programme makes multiple passes over the same data or calls to the same function a cache might be useful.
We avoid redundant computations because the results to previous work can be accessed in <code class="highlighter-rouge">O(1)</code> time.</p>

<p>For instance consider the problem:-</p>
<ul>
  <li>given an array of strings</li>
  <li>find the distance between the two closest equal strings.</li>
</ul>

<p>A brute-force approach might be to find – for each element of the array – the next element of the array equal to it.
So a carefree solution might be the following:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">bf_nearest_repeat</span><span class="p">(</span><span class="n">l</span><span class="p">):</span> <span class="c"># O(n^2)</span>
    <span class="n">gap</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="n">j</span> <span class="o">+</span> <span class="n">gap</span><span class="p">)):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">gap</span><span class="p">):</span>
                <span class="n">gap</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">gap</span></code></pre></figure>

<p>which has <code class="highlighter-rouge">O(n^2)</code> time complexity and <code class="highlighter-rouge">O(1)</code> space complexity.
Notice also that we are making multiple passes over the data.</p>

<p>A cache improves the time complexity because it makes the outer loop redundant.
We don’t have to iterate through the array for each element but only keep track of the most recent occurrence of each element.
This could look like:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">nearest_repeat</span><span class="p">(</span><span class="n">l</span><span class="p">):</span> <span class="c"># O(n)</span>
    <span class="n">last_occurrence</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">gap</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s">'inf'</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ele</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ele</span> <span class="ow">in</span> <span class="n">last_occurrence</span> <span class="ow">and</span> <span class="n">gap</span> <span class="o">&gt;</span> <span class="n">i</span><span class="o">-</span><span class="n">last_occurrence</span><span class="p">[</span><span class="n">ele</span><span class="p">]:</span>
            <span class="n">gap</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">last_occurrence</span><span class="p">[</span><span class="n">ele</span><span class="p">]</span>
        <span class="n">last_occurrence</span><span class="p">[</span><span class="n">ele</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
    <span class="k">return</span> <span class="n">gap</span></code></pre></figure>

<p>which has time complexity <code class="highlighter-rouge">O(n)</code> and <code class="highlighter-rouge">O(n)</code> space complexity.</p>


      
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.0/anchor.min.js" integrity="sha256-lZaRhKri35AyJSypXXs4o6OPFTbTmUoltBbDCbdzegg=" crossorigin="anonymous"></script>
    <script>anchors.add();</script>
    
  </body>
</html>
